{"version":3,"file":"fdc3-installer.esm.js","sources":["../src/api/infrastructure/installerMetadata.ts","../src/types/installer/InstallerConfigSource.ts","../src/api/infrastructure/getContainerOrigin.ts","../src/api/infrastructure/getInstallerConfig.ts","../src/types/discovery/DiscoveryStrategyType.ts","../src/api/executors/discoveryStrategyExecutors.ts","../src/types/creation/CreationStrategyType.ts","../src/api/executors/creationStrategyExecutors.ts","../src/types/bootstrap/BootstrapStrategyType.ts","../src/api/executors/bootstrapStrategyExecutors.ts","../src/api/infrastructure/validateAgent.ts","../src/api/fdc3Installer.ts"],"sourcesContent":["export const fdc3InstallerName = 'Open FDC3 Installer';\nexport const fdc3InstallerVersion = '0.7.37';\n","export enum InstallerConfigSource {\n  Container = 'Container',\n  App = 'App'\n}\n","export const getContainerOrigin = (): string => {\n  let containerOrigin: string;\n  if ((window.parent) && (window.parent !== window)) {\n    // Application is running in an iframe inside a micro-frontend container\n    if ((window.location.ancestorOrigins) && (window.location.ancestorOrigins.length > 0)) {\n      // Use the origin of ultimate ancestor browsing context.  This handles both the (common) iframe and (uncommon) nested-iframe scenarios.\n      // Note that this assumes the micro-frontend container itself is *not* hosted in an iframe (which would arguably be an odd thing to do)\n      containerOrigin = new URL(window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1]).origin;\n    }\n    else {\n      throw new Error(`ancestorOrigins for application at url '${window.location.href}' could not be found in window.location`);\n    }\n  }\n  else if (window.opener) {\n    // Application is running in an external window spawned from a micro-frontend container.\n    // Note that this assumes the application was spawned *directly* by the micro-frontend container.  This might be a reasonable assumption in\n    // the case where the container and application use an FDC3 Agent which relies on local native browser event APIs for FDC3 messaging, because\n    // such an FDC3 Agent will likely require an 'FDC3 messaging router' of sorts in the container, and so the FDC3 Agent's fdc3.open() method can\n    // delegate the actual window.open() invocation to the container - meaning that  document.referrer  will in fact reference the container as expected.\n    // However, there will be some scenarios where this would not work in the case of a FDC3 Agent which relies on WebSockets for cloud-based FDC3 messaging, because\n    // in that scenario the lack of an 'FDC3 messaging router' in the container (because there would be no requirement for a container at all) would mean that application\n    // windows would be spawned from each other (rather than from a container) and therefore  document.referrer  *could* reference another application, rather than a container.\n    // In practice, it's fair to say that a container-based discovery strategy is neither appropriate (or supported by this library) for the case of applications\n    // using cloud-based FDC3 Agent implementations.  Those applications can however by supported by this library by simply using an application-based discovery strategy.\n    containerOrigin = new URL(document.referrer).origin;\n  }\n  else {\n    throw new Error(`Failed to determine container origin because application at url '${window.location.href}' does not appear to be running inside a micro-frontend container`);\n  }\n  return containerOrigin;\n};\n","import { InstallerConfigSource } from '../../types/installer/InstallerConfigSource';\nimport { InstallerConfig } from '../../types/installer/InstallerConfig';\nimport { fdc3InstallerName } from './installerMetadata';\nimport { getContainerOrigin } from './getContainerOrigin';\n\nexport const getInstallerConfig = async (configSource: InstallerConfigSource): Promise<InstallerConfig> => {\n  console.log(`${fdc3InstallerName} - Loading installer config for source '${configSource}'...`);\n  let installerConfig: InstallerConfig;\n  // Attempt to load installer config\n  const fdc3InstallerConfigFileName = 'fdc3-installer-config.json';\n  const fdc3InstallerConfigUrl = (configSource === InstallerConfigSource.Container) ? `${getContainerOrigin()}/${fdc3InstallerConfigFileName}` : fdc3InstallerConfigFileName;\n  const icResponse = await fetch(fdc3InstallerConfigUrl);\n  if (!icResponse.ok) {\n    throw new Error(`Installer config at url '${fdc3InstallerConfigUrl}' for configSource '${configSource}' could not be located`);\n  }\n  try {\n    installerConfig = await icResponse.json();\n  }\n  catch (e) {\n    throw new Error(`Installer config at url '${fdc3InstallerConfigUrl}' for configSource '${configSource}' could not be parsed`);\n  }\n\n  // Inline providerDirectory (defined within the installer config) always take precedence over an externally-defined equivalent.\n  // Therefore check whether providerDirectory exists in installer config, and if not then attempt to load externally using providerDirectoryUrl.\n  if ((!installerConfig.providerDirectory) || (installerConfig.providerDirectory.length === 0)) {\n    if (!installerConfig.providerDirectoryUrl) {\n      throw new Error(`No providerDirectory or providerDirectoryUrl could be found in config`);\n    }\n    else {\n      const pdResponse = await fetch(installerConfig.providerDirectoryUrl);\n      if (!pdResponse.ok) {\n        throw new Error(`Provider directory at url '${installerConfig.providerDirectoryUrl}' could not be located`);\n      }\n      try {\n        installerConfig.providerDirectory = await pdResponse.json();\n      }\n      catch (e) {\n        throw new Error(`Provider directory at url '${installerConfig.providerDirectoryUrl}' could not be parsed`);\n      }\n      if ((!installerConfig.providerDirectory) || (installerConfig.providerDirectory.length === 0)) {\n        throw new Error(`Provider directory at url '${installerConfig.providerDirectoryUrl}' is empty`);\n      }\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    resolve(installerConfig);\n  });\n};\n","export enum DiscoveryStrategyType {\n  ContainerExplicit = 'ContainerExplicit',\n  ContainerOrigin = 'ContainerOrigin',\n  AppExplicit = 'AppExplicit',\n  AppOrigin = 'AppOrigin',\n  AppQuerystring = 'AppQuerystring',\n  AppWindowName = 'AppWindowName',\n  AppSessionStorage = 'AppSessionStorage'\n}\n","import { DiscoveryAppExplicitStrategy, DiscoveryAppOriginStrategy, DiscoveryAppQuerystringStrategy, DiscoveryAppSessionStorageStrategy, DiscoveryAppWindowNameStrategy, DiscoveryContainerExplicitStrategy, DiscoveryContainerOriginStrategy, OriginProviderIdMapping, ParamValueProviderIdMapping } from '../../types/discovery/DiscoveryStrategies';\nimport { DiscoveryStrategyType } from '../../types/discovery/DiscoveryStrategyType';\nimport { ProviderID } from '../../types/provider/ProviderID';\nimport { getContainerOrigin } from '../infrastructure/getContainerOrigin';\nimport { fdc3InstallerName } from '../infrastructure/installerMetadata';\n\ntype DiscoveryStrategyExecutor = (discoveryStrategy: any) => ProviderID;\n\n\nconst discoveryContainerExplicitStrategyExecutor: DiscoveryStrategyExecutor = (discoveryStrategy: DiscoveryContainerExplicitStrategy): ProviderID => {\n  if (!discoveryStrategy.providerId) {\n    throw new Error(`providerId could not be found in discoveryStrategy`);\n  }\n  return discoveryStrategy.providerId;\n}\n\n\nconst discoveryContainerOriginStrategyExecutor: DiscoveryStrategyExecutor = (discoveryStrategy: DiscoveryContainerOriginStrategy): ProviderID => {\n  let originProviderIdMapping: OriginProviderIdMapping;\n  const containerOrigin = getContainerOrigin();\n  const originProviderIdMappings: OriginProviderIdMapping[] = discoveryStrategy.originProviderIdMappings.filter(opm => opm.origin === containerOrigin);\n  if (originProviderIdMappings.length === 0) {\n    throw new Error(`originProviderIdMapping for origin '${containerOrigin}' could not be found in discoveryStrategy`);\n  }\n  else if (originProviderIdMappings.length > 1) {\n    throw new Error(`Multiple originProviderIdMapping items with origin '${containerOrigin}' found in discoveryStrategy`);\n  }\n  else {\n    originProviderIdMapping = originProviderIdMappings[0];\n  }\n  return originProviderIdMapping.providerId;\n}\n\n\nconst discoveryAppExplicitStrategyExecutor: DiscoveryStrategyExecutor = (discoveryStrategy: DiscoveryAppExplicitStrategy): ProviderID => {\n  if (!discoveryStrategy.providerId) {\n    throw new Error(`providerId could not be found in discoveryStrategy`);\n  }\n  return discoveryStrategy.providerId;\n}\n\n\nconst discoveryAppOriginStrategyExecutor: DiscoveryStrategyExecutor = (discoveryStrategy: DiscoveryAppOriginStrategy): ProviderID => {\n  let originProviderIdMapping: OriginProviderIdMapping;\n  const originProviderIdMappings: OriginProviderIdMapping[] = discoveryStrategy.originProviderIdMappings.filter(opm => opm.origin === window.location.origin);\n  if (originProviderIdMappings.length === 0) {\n    throw new Error(`originProviderIdMapping for origin '${window.location.origin}' could not be found in discoveryStrategy`);\n  }\n  else if (originProviderIdMappings.length > 1) {\n    throw new Error(`Multiple originProviderIdMapping items with origin '${window.location.origin}' found in discoveryStrategy`);\n  }\n  else {\n    originProviderIdMapping = originProviderIdMappings[0];\n  }\n  return originProviderIdMapping.providerId;\n}\n\n\nconst discoveryAppQuerystringStrategyExecutor: DiscoveryStrategyExecutor = (discoveryStrategy: DiscoveryAppQuerystringStrategy): ProviderID => {\n  let paramValueProviderIdMapping: ParamValueProviderIdMapping;\n  if (!discoveryStrategy.paramName) {\n    throw new Error(`paramName could not be found in discoveryStrategy`);\n  }\n  const runtimeAppParams = new URL(window.location.href).searchParams;\n  const runtimeAppParamValue = runtimeAppParams.get(discoveryStrategy.paramName);\n  if (!runtimeAppParamValue) {\n    throw new Error(`param '${discoveryStrategy.paramName}' could not be found in application url`);\n  }\n  const paramValueProviderIdMappings: ParamValueProviderIdMapping[] = discoveryStrategy.paramValueProviderIdMappings.filter(pvpm => pvpm.paramValue === runtimeAppParamValue);\n  if (paramValueProviderIdMappings.length === 0) {\n    throw new Error(`paramValueProviderIdMapping for paramValue '${runtimeAppParamValue}' could not be found in discoveryStrategy`);\n  }\n  else if (paramValueProviderIdMappings.length > 1) {\n    throw new Error(`Multiple paramValueProviderIdMapping items with paramValue '${runtimeAppParamValue}' found in discoveryStrategy`);\n  }\n  else {\n    paramValueProviderIdMapping = paramValueProviderIdMappings[0];\n  }\n  return paramValueProviderIdMapping.providerId;\n}\n\n\nconst discoveryAppWindowNameStrategyExecutor: DiscoveryStrategyExecutor = (discoveryStrategy: DiscoveryAppWindowNameStrategy): ProviderID => {\n  throw new Error('Not implemented');\n  // Use:\n  //  discoveryStrategy.valueDelimiter\n  //  discoveryStrategy.providerNameOrdinal\n  //  discoveryStrategy.providerVersionOrdinal\n  //  discoveryStrategy.providerFdc3VersionOrdinal\n  // For example:\n  //  * use window.name to get the string containing the values that have been projected through to the app window from the micro-frontend container that spawned it\n  //  * Create and return a ProviderID object\n}\n\n\nconst discoveryAppSessionStorageStrategyExecutor: DiscoveryStrategyExecutor = (discoveryStrategy: DiscoveryAppSessionStorageStrategy): ProviderID => {\n  throw new Error('Not implemented');\n  // Use:\n  //  discoveryStrategy.keyName\n  //  discoveryStrategy.providerNameValuePath\n  //  discoveryStrategy.providerVersionValuePath\n  //  discoveryStrategy.providerFdc3VersionValuePath\n  // For example:\n  //  * use something like this to get the item value:  sessionStorage.getItem(discoveryStrategy.keyName)\n  //  * parse the stringified item value into an object, and use Lodash get() method or similar to get the values specified by the xxxValuePath properties from the object\n  //  * Create and return a ProviderID object\n  // Further thoughts:\n  //  * Could consider supporting a stringified ProviderID object (still using keyName to retrieve) but using implicit xxxValuePath properties unless they are explicitly supplied\n  //  * Additionally, could also potentially support three separate item key names for the three properties (instead of having a single item value and parsing it into an object)\n}\n\n\nconst discoveryStrategyExecutors = new Map<DiscoveryStrategyType, DiscoveryStrategyExecutor>();\ndiscoveryStrategyExecutors.set(DiscoveryStrategyType.ContainerExplicit, discoveryContainerExplicitStrategyExecutor);\ndiscoveryStrategyExecutors.set(DiscoveryStrategyType.ContainerOrigin, discoveryContainerOriginStrategyExecutor);\ndiscoveryStrategyExecutors.set(DiscoveryStrategyType.AppExplicit, discoveryAppExplicitStrategyExecutor);\ndiscoveryStrategyExecutors.set(DiscoveryStrategyType.AppOrigin, discoveryAppOriginStrategyExecutor);\ndiscoveryStrategyExecutors.set(DiscoveryStrategyType.AppQuerystring, discoveryAppQuerystringStrategyExecutor);\ndiscoveryStrategyExecutors.set(DiscoveryStrategyType.AppWindowName, discoveryAppWindowNameStrategyExecutor);\ndiscoveryStrategyExecutors.set(DiscoveryStrategyType.AppSessionStorage, discoveryAppSessionStorageStrategyExecutor);\n\n\nexport const getDiscoveryStrategyExecutor = (discoveryStrategyType: DiscoveryStrategyType): DiscoveryStrategyExecutor => {\n  console.log(`${fdc3InstallerName} - Getting discovery strategy executor for type '${discoveryStrategyType}'...`);\n  const discoveryStrategyExecutor = discoveryStrategyExecutors.get(discoveryStrategyType);\n  if (!discoveryStrategyExecutor) {\n    throw new Error(`Implementation for discoveryStrategy type '${discoveryStrategyType}' could not be found`);\n  }\n  return discoveryStrategyExecutor;\n};\n","export enum CreationStrategyType {\n  ClassInstance = 'ClassInstance',\n  Class = 'Class',\n  FactoryFunction = 'FactoryFunction',\n  FactoryClassInstance = 'FactoryClassInstance',\n  FactoryClass = 'FactoryClass',\n  StaticFactoryClass = 'StaticFactoryClass'\n}\n","import { CreationClassInstanceStrategy, CreationClassStrategy, CreationFactoryClassInstanceStrategy, CreationFactoryClassStrategy, CreationFactoryFunctionStrategy, CreationStaticFactoryClassStrategy } from '../../types/creation/CreationStrategies';\nimport { CreationStrategyType } from '../../types/creation/CreationStrategyType';\nimport { fdc3InstallerName } from '../infrastructure/installerMetadata';\n\ntype CreationStrategyExecutor = (creationStrategy: any, fdc3AgentModuleObject: any) => Promise</*DesktopAgent*/any>;\n\n\nconst creationClassInstanceStrategyExecutor: CreationStrategyExecutor = (creationStrategy: CreationClassInstanceStrategy, fdc3AgentModuleObject: any): Promise</*DesktopAgent*/any> => {\n  if (typeof fdc3AgentModuleObject !== 'object') {\n    throw new Error(`Expected fdc3AgentModuleObject to be a class instance, but it is of type '${typeof fdc3AgentModuleObject}'`);\n  }\n  return new Promise((resolve, reject) => {\n    resolve(fdc3AgentModuleObject);\n  });\n}\n\n\nconst creationClassStrategyExecutor: CreationStrategyExecutor = (creationStrategy: CreationClassStrategy, fdc3AgentModuleObject: any): Promise</*DesktopAgent*/any> => {\n  if ((typeof fdc3AgentModuleObject !== 'function') || (typeof fdc3AgentModuleObject.constructor !== 'function')) {\n    throw new Error(`Expected fdc3AgentModuleObject to be a class, but it is of type '${typeof fdc3AgentModuleObject}'`);\n  }\n  if ((!!creationStrategy.constructorArgs) && (!Array.isArray(creationStrategy.constructorArgs))) {\n    throw new Error('creationStrategy.functionArgs in config needs to be an array');\n  }\n  return new Promise((resolve, reject) => {\n    const fdc3Agent: /*DesktopAgent*/any = new (Function.prototype.bind.call(fdc3AgentModuleObject, undefined, ...creationStrategy.constructorArgs))();\n    resolve(fdc3Agent);\n  });\n}\n\n\nconst creationFactoryFunctionStrategyExecutor: CreationStrategyExecutor = async (creationStrategy: CreationFactoryFunctionStrategy, fdc3AgentModuleObject: Function): Promise</*DesktopAgent*/any> => {\n  if (typeof fdc3AgentModuleObject !== 'function') {\n    throw new Error(`Expected fdc3AgentModuleObject to be a factory function, but it is of type '${typeof fdc3AgentModuleObject}'`);\n  }\n  if ((!!creationStrategy.functionArgs) && (!Array.isArray(creationStrategy.functionArgs))) {\n    throw new Error('creationStrategy.functionArgs in config needs to be an array');\n  }\n  return await fdc3AgentModuleObject.apply(undefined, creationStrategy.functionArgs);\n}\n\n\nconst creationFactoryClassInstanceStrategyExecutor: CreationStrategyExecutor = async (creationStrategy: CreationFactoryClassInstanceStrategy, fdc3AgentModuleObject: any): Promise</*DesktopAgent*/any> => {\n  if (typeof fdc3AgentModuleObject !== 'object') {\n    throw new Error(`Expected fdc3AgentModuleObject to be a factory class instance, but it is of type '${typeof fdc3AgentModuleObject}'`);\n  }\n  if (!creationStrategy.methodName) {\n    throw new Error('Missing creationStrategy.methodName in config');\n  }\n  const factoryMethod: Function = fdc3AgentModuleObject[creationStrategy.methodName];\n  if (!factoryMethod) {\n    throw new Error(`Factory method named '${creationStrategy.methodName}' could not be found on factory class instance`);\n  }\n  if (typeof factoryMethod !== 'function') {\n    throw new Error(`Expected factory method named '${creationStrategy.methodName}' to be a method, but it is of type '${typeof factoryMethod}'`);\n  }\n  if ((!!creationStrategy.methodArgs) && (!Array.isArray(creationStrategy.methodArgs))) {\n    throw new Error('creationStrategy.methodArgs in config needs to be an array');\n  }\n  return await factoryMethod.apply(fdc3AgentModuleObject, creationStrategy.methodArgs);\n}\n\n\nconst creationFactoryClassStrategyExecutor: CreationStrategyExecutor = (creationStrategy: CreationFactoryClassStrategy, fdc3AgentModuleObject: any): Promise</*DesktopAgent*/any> => {\n  throw new Error('Not implemented');\n  // Use:\n  //  creationStrategy.constructorArgs\n  //  creationStrategy.methodName\n  //  creationStrategy.methodArgs\n}\n\n\nconst creationStaticFactoryClassStrategyExecutor: CreationStrategyExecutor = (creationStrategy: CreationStaticFactoryClassStrategy, fdc3AgentModuleObject: any): Promise</*DesktopAgent*/any> => {\n  throw new Error('Not implemented');\n  // Use:\n  //  creationStrategy.methodName\n  //  creationStrategy.methodArgs\n}\n\n\nconst creationStrategyExecutors = new Map<CreationStrategyType, CreationStrategyExecutor>();\ncreationStrategyExecutors.set(CreationStrategyType.ClassInstance, creationClassInstanceStrategyExecutor);\ncreationStrategyExecutors.set(CreationStrategyType.Class, creationClassStrategyExecutor);\ncreationStrategyExecutors.set(CreationStrategyType.FactoryFunction, creationFactoryFunctionStrategyExecutor);\ncreationStrategyExecutors.set(CreationStrategyType.FactoryClassInstance, creationFactoryClassInstanceStrategyExecutor);\ncreationStrategyExecutors.set(CreationStrategyType.FactoryClass, creationFactoryClassStrategyExecutor);\ncreationStrategyExecutors.set(CreationStrategyType.StaticFactoryClass, creationStaticFactoryClassStrategyExecutor);\n\nexport const getCreationStrategyExecutor = (creationStrategyType: CreationStrategyType): CreationStrategyExecutor => {\n  console.log(`${fdc3InstallerName} - Getting creation strategy executor for type '${creationStrategyType}'...`);\n  const creationStrategyExecutor = creationStrategyExecutors.get(creationStrategyType);\n  if (!creationStrategyExecutor) {\n    throw new Error(`Implementation for creationStrategyType '${creationStrategyType}' could not be found`);\n  }\n  return creationStrategyExecutor;\n};\n","export enum BootstrapStrategyType {\n  Implicit = 'Implicit',\n  Explicit = 'Explicit'\n}\n","import { BootstrapExplicitStrategy, BootstrapImplicitStrategy } from '../../types/bootstrap/BootstrapStrategies';\nimport { BootstrapStrategyType } from '../../types/bootstrap/BootstrapStrategyType';\nimport { fdc3InstallerName } from '../infrastructure/installerMetadata';\n\ntype BootstrapStrategyExecutor = (bootstrapStrategy: any, fdc3Agent: any) => Promise<void>;\n\n\nconst bootstrapImplicitStrategyExecutor: BootstrapStrategyExecutor = async (bootstrapStrategy: BootstrapImplicitStrategy, fdc3Agent: any): Promise<void> => {\n  // FDC3 Agent was bootstrapped implicitly when it was imported / created, so there is no work to do here\n  return new Promise((resolve, reject) => {\n    resolve();\n  });\n}\n\n\nconst bootstrapExplicitStrategyExecutor: BootstrapStrategyExecutor = async (bootstrapStrategy: BootstrapExplicitStrategy, fdc3Agent: any): Promise<void> => {\n  if (!bootstrapStrategy.methodName) {\n    throw new Error('Missing bootstrapStrategy.methodName in config');\n  }\n  const fdc3AgentBootstrapMethod: Function = fdc3Agent[bootstrapStrategy.methodName];\n  if (!fdc3AgentBootstrapMethod) {\n    throw new Error(`Bootstrap method named '${bootstrapStrategy.methodName}' could not be found on FDC3 Agent`);\n  }\n  if (typeof fdc3AgentBootstrapMethod !== 'function') {\n    throw new Error(`Expected bootstrap method named '${bootstrapStrategy.methodName}' to be a method, but it is of type '${typeof fdc3AgentBootstrapMethod}'`);\n  }\n  if ((!!bootstrapStrategy.methodArgs) && (!Array.isArray(bootstrapStrategy.methodArgs))) {\n    throw new Error('bootstrapStrategy.methodArgs in config needs to be an array');\n  }\n  await fdc3AgentBootstrapMethod.apply(fdc3Agent, bootstrapStrategy.methodArgs);\n}\n\n\nconst bootstrapStrategyExecutors = new Map<BootstrapStrategyType, BootstrapStrategyExecutor>();\nbootstrapStrategyExecutors.set(BootstrapStrategyType.Implicit, bootstrapImplicitStrategyExecutor);\nbootstrapStrategyExecutors.set(BootstrapStrategyType.Explicit, bootstrapExplicitStrategyExecutor);\n\nexport const getBootstrapStrategyExecutor = (bootstrapStrategyType: BootstrapStrategyType): BootstrapStrategyExecutor => {\n  console.log(`${fdc3InstallerName} - Getting bootstrap strategy executor for type '${bootstrapStrategyType}'...`);\n  const bootstrapStrategyExecutor = bootstrapStrategyExecutors.get(bootstrapStrategyType);\n  if (!bootstrapStrategyExecutor) {\n    throw new Error(`Implementation for bootstrapStrategyType '${bootstrapStrategyType}' could not be found`);\n  }\n  return bootstrapStrategyExecutor;\n};\n","import { ProviderID } from '../../types/provider/ProviderID';\n\nconst nameof = <T>(name: keyof T) => name;\n\nexport const validateAgent = (providerId: ProviderID, installedImplementation: any): void => {\n  //TODO - Consider improving this as the naive string-based equality test for version / fdc3Version would actually fail validation for '1.2' against '1.2.0' for example\n  let mismatchedPropValues: string[] = [];\n  if (installedImplementation.provider !== providerId.name) {\n    mismatchedPropValues.push(nameof<ProviderID>('name'));\n  }\n  if (installedImplementation.providerVersion !== providerId.version) {\n    mismatchedPropValues.push(nameof<ProviderID>('version'));\n  }\n  if (installedImplementation.fdc3Version !== providerId.fdc3Version) {\n    mismatchedPropValues.push(nameof<ProviderID>('fdc3Version'));\n  }\n\n  if (mismatchedPropValues.length > 0) {\n    console.error(`Installed provider implementation does not match providerId specified in provider directory entry (mismatched properties: ${mismatchedPropValues.join(', ')})`);\n    console.error('Provider directory entry:');\n    console.error(providerId);\n    console.error('Installed provider implementation');\n    console.error(installedImplementation);\n    throw new Error('Invalid agent');\n  }\n};\n","import { DesktopAgentInstaller } from '../types/installer/DesktopAgentInstaller';\nimport { InstallerMetadata } from '../types/installer/InstallerMetadata';\nimport { InstallerConfigSource } from '../types/installer/InstallerConfigSource';\nimport { ProviderID } from '../types/provider/ProviderID';\nimport { ProviderDefinition } from '../types/provider/ProviderDefinition';\nimport { InstallerConfig } from '../types/installer/InstallerConfig';\nimport { InstallResolution } from '../types/installer/InstallResolution';\nimport { fdc3InstallerName, fdc3InstallerVersion } from './infrastructure/installerMetadata';\nimport { getInstallerConfig } from './infrastructure/getInstallerConfig';\nimport { getDiscoveryStrategyExecutor } from './executors/discoveryStrategyExecutors';\nimport { getCreationStrategyExecutor } from './executors/creationStrategyExecutors';\nimport { getBootstrapStrategyExecutor } from './executors/bootstrapStrategyExecutors';\nimport { validateAgent } from './infrastructure/validateAgent';\n\ndeclare global {\n  interface Window {\n    fdc3: /*DesktopAgent*/any;\n  }\n}\n\nexport const fdc3Installer: DesktopAgentInstaller = {\n  getInfo: function(): Promise<InstallerMetadata> {\n    const installerMetadata: InstallerMetadata = {\n      installerName: fdc3InstallerName,\n      installerVersion: fdc3InstallerVersion\n    };\n    return new Promise((resolve, reject) => {\n      resolve(installerMetadata);\n    });\n  },\n\n  installAgent: async function(configSource: InstallerConfigSource): Promise<InstallResolution> {\n    let providerDef: ProviderDefinition;\n    let fdc3Agent: /*DesktopAgent*/any;\n    if (window.fdc3) {\n      fdc3Agent = window.fdc3;\n      console.log(`%c**\\n** FDC3 is already supported in this environment. Therefore ${fdc3InstallerName} v${fdc3InstallerVersion} will *not* attempt to discover and install an FDC3 Agent using the installer config. **\\n**`, 'font-weight:bold;');\n    }\n    else {\n      // Load the installer config for the given config source i.e. either from the application root or from the container root\n      const installerConfig: InstallerConfig = await getInstallerConfig(configSource);\n      // Determine the FDC3 Agent by using the discovery strategy specified in the installer config\n      if (!installerConfig.discoveryStrategy) {\n        throw new Error('Missing discoveryStrategy in config');\n      }\n      const discoveryStrategyExecutor = getDiscoveryStrategyExecutor(installerConfig.discoveryStrategy.type);\n      const discoveredProviderId: ProviderID = discoveryStrategyExecutor(installerConfig.discoveryStrategy);\n      // Retrieve the provider definition for the given FDC3 Agent by using the installer config's provider directory\n      console.log(`${fdc3InstallerName} - Retrieving provider definition for provider '${discoveredProviderId.name}'...`);\n      const providerDefs: ProviderDefinition[] = installerConfig.providerDirectory!.filter((pd: ProviderDefinition) => ((pd.providerId.name === discoveredProviderId.name) && ((!discoveredProviderId.version) || (pd.providerId.version === discoveredProviderId.version)) && ((!discoveredProviderId.fdc3Version) || (pd.providerId.fdc3Version === discoveredProviderId.fdc3Version))));\n      if (providerDefs.length === 0) {\n        throw new Error(`No provider definition '${discoveredProviderId.name}' could be found in provider directory config`);\n      }\n      else if (providerDefs.length > 1) {\n        throw new Error(`Multiple provider definitions for '${discoveredProviderId.name}' found in provider directory config`);\n      }\n      else {\n        providerDef = providerDefs[0];\n        // Import the FDC3 Agent module using the module url defined for the provider implementation\n        console.log(`${fdc3InstallerName} - Importing FDC3 Agent module using url '${providerDef.providerImplementation.moduleUrl}'...`);\n        const fdc3AgentModule = await import(/* webpackIgnore: true */providerDef.providerImplementation.moduleUrl);\n        if (!fdc3AgentModule) {\n          throw new Error(`Failure obtaining module from FDC3 Agent at url '${providerDef.providerImplementation.moduleUrl}'`);\n        }\n        // Get the FDC3 Agent module object using the exported name defined for the provider implementation\n        const effectiveExportedName = providerDef.providerImplementation.exportedName || \"default\"\n        console.log(`${fdc3InstallerName} - Getting FDC3 Agent module object using name '${effectiveExportedName}'...`);\n        const fdc3AgentModuleObject: any = fdc3AgentModule[effectiveExportedName];\n        if (!fdc3AgentModuleObject) {\n          throw new Error(`Failure obtaining exported object named '${effectiveExportedName}' from FDC3 Agent at url '${providerDef.providerImplementation.moduleUrl}'`);\n        }\n        // Create the FDC3 Agent by using the creation strategy defined for the provider implementation\n        if (!providerDef.providerImplementation.creationStrategy) {\n          throw new Error('Missing creationStrategy in config');\n        }\n        const creationStrategyExecutor = getCreationStrategyExecutor(providerDef.providerImplementation.creationStrategy.type);\n        console.log(`${fdc3InstallerName} - Creating provider ${providerDef.providerId.name} v${providerDef.providerId.version}...`);\n        fdc3Agent = await creationStrategyExecutor(providerDef.providerImplementation.creationStrategy, fdc3AgentModuleObject);\n        // Bootstrap the FDC3 Agent (if required) by using the bootstrap strategy defined for the provider implementation\n        if (!providerDef.providerImplementation.bootstrapStrategy) {\n          throw new Error('Missing bootstrapStrategy in config');\n        }\n        const bootstrapStrategyExecutor = getBootstrapStrategyExecutor(providerDef.providerImplementation.bootstrapStrategy.type);\n        console.log(`${fdc3InstallerName} - Bootstrapping provider ${providerDef.providerId.name} v${providerDef.providerId.version}...`);\n        await bootstrapStrategyExecutor(providerDef.providerImplementation.bootstrapStrategy, fdc3Agent);\n        // Validate the FDC3 Agent that has actually been imported/installed against the details in the provider definition (if required)\n        if (installerConfig.discoveryStrategy.validateProvider) {\n          console.log(`${fdc3InstallerName} - Validating installed provider ${providerDef.providerId.name} v${providerDef.providerId.version}...`);\n          const installedImplementation = await fdc3Agent.getInfo();\n          validateAgent(providerDef.providerId, installedImplementation);\n        }\n        console.log(`${fdc3InstallerName} - Completed discovery, import, creation and bootstrap for provider ${providerDef.providerId.name} v${providerDef.providerId.version}`);\n        // console.log(fdc3Agent);\n        console.log(`${fdc3InstallerName} - All done`);\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const installResolution: InstallResolution = {\n        providerDefinition: providerDef,\n        fdc3: fdc3Agent\n      };\n      resolve(installResolution);\n    });\n  }\n}\n"],"names":["fdc3InstallerName","fdc3InstallerVersion","InstallerConfigSource","getContainerOrigin","containerOrigin","window","parent","location","ancestorOrigins","length","URL","origin","Error","href","opener","document","referrer","getInstallerConfig","configSource","console","log","fdc3InstallerConfigFileName","fdc3InstallerConfigUrl","Container","fetch","icResponse","ok","json","installerConfig","providerDirectory","providerDirectoryUrl","pdResponse","Promise","resolve","reject","DiscoveryStrategyType","discoveryContainerExplicitStrategyExecutor","discoveryStrategy","providerId","discoveryContainerOriginStrategyExecutor","originProviderIdMapping","originProviderIdMappings","filter","opm","discoveryAppExplicitStrategyExecutor","discoveryAppOriginStrategyExecutor","discoveryAppQuerystringStrategyExecutor","paramValueProviderIdMapping","paramName","runtimeAppParams","searchParams","runtimeAppParamValue","get","paramValueProviderIdMappings","pvpm","paramValue","discoveryAppWindowNameStrategyExecutor","discoveryAppSessionStorageStrategyExecutor","discoveryStrategyExecutors","Map","set","ContainerExplicit","ContainerOrigin","AppExplicit","AppOrigin","AppQuerystring","AppWindowName","AppSessionStorage","getDiscoveryStrategyExecutor","discoveryStrategyType","discoveryStrategyExecutor","CreationStrategyType","creationClassInstanceStrategyExecutor","creationStrategy","fdc3AgentModuleObject","creationClassStrategyExecutor","constructor","constructorArgs","Array","isArray","fdc3Agent","Function","prototype","bind","call","undefined","creationFactoryFunctionStrategyExecutor","functionArgs","apply","creationFactoryClassInstanceStrategyExecutor","methodName","factoryMethod","methodArgs","creationFactoryClassStrategyExecutor","creationStaticFactoryClassStrategyExecutor","creationStrategyExecutors","ClassInstance","Class","FactoryFunction","FactoryClassInstance","FactoryClass","StaticFactoryClass","getCreationStrategyExecutor","creationStrategyType","creationStrategyExecutor","BootstrapStrategyType","bootstrapImplicitStrategyExecutor","bootstrapStrategy","bootstrapExplicitStrategyExecutor","fdc3AgentBootstrapMethod","bootstrapStrategyExecutors","Implicit","Explicit","getBootstrapStrategyExecutor","bootstrapStrategyType","bootstrapStrategyExecutor","nameof","name","validateAgent","installedImplementation","mismatchedPropValues","provider","push","providerVersion","version","fdc3Version","error","join","fdc3Installer","getInfo","installerMetadata","installerName","installerVersion","installAgent","fdc3","type","discoveredProviderId","providerDefs","pd","providerDef","providerImplementation","moduleUrl","fdc3AgentModule","effectiveExportedName","exportedName","validateProvider","installResolution","providerDefinition"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,IAAMA,iBAAiB,GAAG,qBAAqB;AAC/C,IAAMC,oBAAoB,GAAG,QAAQ;;ICDhCC,qBAGX;AAHD,WAAYA,qBAAqB;EAC/BA,gDAAuB;EACvBA,oCAAW;AACb,CAAC,EAHWA,qBAAqB,KAArBA,qBAAqB;;ACA1B,IAAMC,kBAAkB,GAAG,SAArBA,kBAAkB;EAC7B,IAAIC,eAAuB;EAC3B,IAAKC,MAAM,CAACC,MAAM,IAAMD,MAAM,CAACC,MAAM,KAAKD,MAAO,EAAE;;IAEjD,IAAKA,MAAM,CAACE,QAAQ,CAACC,eAAe,IAAMH,MAAM,CAACE,QAAQ,CAACC,eAAe,CAACC,MAAM,GAAG,CAAE,EAAE;;;MAGrFL,eAAe,GAAG,IAAIM,GAAG,CAACL,MAAM,CAACE,QAAQ,CAACC,eAAe,CAACH,MAAM,CAACE,QAAQ,CAACC,eAAe,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC,CAACE,MAAM;KAC9G,MACI;MACH,MAAM,IAAIC,KAAK,8CAA4CP,MAAM,CAACE,QAAQ,CAACM,IAAI,6CAA0C;;GAE5H,MACI,IAAIR,MAAM,CAACS,MAAM,EAAE;;;;;;;;;;;IAWtBV,eAAe,GAAG,IAAIM,GAAG,CAACK,QAAQ,CAACC,QAAQ,CAAC,CAACL,MAAM;GACpD,MACI;IACH,MAAM,IAAIC,KAAK,uEAAqEP,MAAM,CAACE,QAAQ,CAACM,IAAI,uEAAoE;;EAE9K,OAAOT,eAAe;AACxB,CAAC;;ACzBM,IAAMa,kBAAkB;EAAA,mFAAG,iBAAOC,YAAmC;IAAA;IAAA;MAAA;QAAA;UAC1EC,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,gDAA2CkB,YAAY,UAAO;;UAGxFG,2BAA2B,GAAG,4BAA4B;UAC1DC,sBAAsB,GAAIJ,YAAY,KAAKhB,qBAAqB,CAACqB,SAAS,GAAOpB,kBAAkB,EAAE,SAAIkB,2BAA2B,GAAKA,2BAA2B;UAAA;UAAA,OACjJG,KAAK,CAACF,sBAAsB,CAAC;QAAA;UAAhDG,UAAU;UAAA,IACXA,UAAU,CAACC,EAAE;YAAA;YAAA;;UAAA,MACV,IAAId,KAAK,+BAA6BU,sBAAsB,4BAAuBJ,YAAY,4BAAyB;QAAA;UAAA;UAAA;UAAA,OAGtGO,UAAU,CAACE,IAAI,EAAE;QAAA;UAAzCC,eAAe;UAAA;UAAA;QAAA;UAAA;UAAA;UAAA,MAGT,IAAIhB,KAAK,+BAA6BU,sBAAsB,4BAAuBJ,YAAY,2BAAwB;QAAA;UAAA,MAK1H,CAACU,eAAe,CAACC,iBAAiB,IAAMD,eAAe,CAACC,iBAAiB,CAACpB,MAAM,KAAK,CAAE;YAAA;YAAA;;UAAA,IACrFmB,eAAe,CAACE,oBAAoB;YAAA;YAAA;;UAAA,MACjC,IAAIlB,KAAK,yEAAyE;QAAA;UAAA;UAAA,OAG/DY,KAAK,CAACI,eAAe,CAACE,oBAAoB,CAAC;QAAA;UAA9DC,UAAU;UAAA,IACXA,UAAU,CAACL,EAAE;YAAA;YAAA;;UAAA,MACV,IAAId,KAAK,iCAA+BgB,eAAe,CAACE,oBAAoB,4BAAyB;QAAA;UAAA;UAAA;UAAA,OAGjEC,UAAU,CAACJ,IAAI,EAAE;QAAA;UAA3DC,eAAe,CAACC,iBAAiB;UAAA;UAAA;QAAA;UAAA;UAAA;UAAA,MAG3B,IAAIjB,KAAK,iCAA+BgB,eAAe,CAACE,oBAAoB,2BAAwB;QAAA;UAAA,MAEvG,CAACF,eAAe,CAACC,iBAAiB,IAAMD,eAAe,CAACC,iBAAiB,CAACpB,MAAM,KAAK,CAAE;YAAA;YAAA;;UAAA,MACpF,IAAIG,KAAK,iCAA+BgB,eAAe,CAACE,oBAAoB,gBAAa;QAAA;UAAA,iCAK9F,IAAIE,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;YACjCD,OAAO,CAACL,eAAe,CAAC;WACzB,CAAC;QAAA;QAAA;UAAA;;;GACH;EAAA,gBA3CYX,kBAAkB;IAAA;;AAAA,GA2C9B;;AChDD,IAAYkB,qBAQX;AARD,WAAYA,qBAAqB;EAC/BA,gEAAuC;EACvCA,4DAAmC;EACnCA,oDAA2B;EAC3BA,gDAAuB;EACvBA,0DAAiC;EACjCA,wDAA+B;EAC/BA,gEAAuC;AACzC,CAAC,EARWA,qBAAqB,KAArBA,qBAAqB;;ACSjC,IAAMC,0CAA0C,GAA8B,SAAxEA,0CAA0C,CAA+BC,iBAAqD;EAClI,IAAI,CAACA,iBAAiB,CAACC,UAAU,EAAE;IACjC,MAAM,IAAI1B,KAAK,sDAAsD;;EAEvE,OAAOyB,iBAAiB,CAACC,UAAU;AACrC,CAAC;AAGD,IAAMC,wCAAwC,GAA8B,SAAtEA,wCAAwC,CAA+BF,iBAAmD;EAC9H,IAAIG,uBAAgD;EACpD,IAAMpC,eAAe,GAAGD,kBAAkB,EAAE;EAC5C,IAAMsC,wBAAwB,GAA8BJ,iBAAiB,CAACI,wBAAwB,CAACC,MAAM,CAAC,UAAAC,GAAG;IAAA,OAAIA,GAAG,CAAChC,MAAM,KAAKP,eAAe;IAAC;EACpJ,IAAIqC,wBAAwB,CAAChC,MAAM,KAAK,CAAC,EAAE;IACzC,MAAM,IAAIG,KAAK,0CAAwCR,eAAe,+CAA4C;GACnH,MACI,IAAIqC,wBAAwB,CAAChC,MAAM,GAAG,CAAC,EAAE;IAC5C,MAAM,IAAIG,KAAK,0DAAwDR,eAAe,kCAA+B;GACtH,MACI;IACHoC,uBAAuB,GAAGC,wBAAwB,CAAC,CAAC,CAAC;;EAEvD,OAAOD,uBAAuB,CAACF,UAAU;AAC3C,CAAC;AAGD,IAAMM,oCAAoC,GAA8B,SAAlEA,oCAAoC,CAA+BP,iBAA+C;EACtH,IAAI,CAACA,iBAAiB,CAACC,UAAU,EAAE;IACjC,MAAM,IAAI1B,KAAK,sDAAsD;;EAEvE,OAAOyB,iBAAiB,CAACC,UAAU;AACrC,CAAC;AAGD,IAAMO,kCAAkC,GAA8B,SAAhEA,kCAAkC,CAA+BR,iBAA6C;EAClH,IAAIG,uBAAgD;EACpD,IAAMC,wBAAwB,GAA8BJ,iBAAiB,CAACI,wBAAwB,CAACC,MAAM,CAAC,UAAAC,GAAG;IAAA,OAAIA,GAAG,CAAChC,MAAM,KAAKN,MAAM,CAACE,QAAQ,CAACI,MAAM;IAAC;EAC3J,IAAI8B,wBAAwB,CAAChC,MAAM,KAAK,CAAC,EAAE;IACzC,MAAM,IAAIG,KAAK,0CAAwCP,MAAM,CAACE,QAAQ,CAACI,MAAM,+CAA4C;GAC1H,MACI,IAAI8B,wBAAwB,CAAChC,MAAM,GAAG,CAAC,EAAE;IAC5C,MAAM,IAAIG,KAAK,0DAAwDP,MAAM,CAACE,QAAQ,CAACI,MAAM,kCAA+B;GAC7H,MACI;IACH6B,uBAAuB,GAAGC,wBAAwB,CAAC,CAAC,CAAC;;EAEvD,OAAOD,uBAAuB,CAACF,UAAU;AAC3C,CAAC;AAGD,IAAMQ,uCAAuC,GAA8B,SAArEA,uCAAuC,CAA+BT,iBAAkD;EAC5H,IAAIU,2BAAwD;EAC5D,IAAI,CAACV,iBAAiB,CAACW,SAAS,EAAE;IAChC,MAAM,IAAIpC,KAAK,qDAAqD;;EAEtE,IAAMqC,gBAAgB,GAAG,IAAIvC,GAAG,CAACL,MAAM,CAACE,QAAQ,CAACM,IAAI,CAAC,CAACqC,YAAY;EACnE,IAAMC,oBAAoB,GAAGF,gBAAgB,CAACG,GAAG,CAACf,iBAAiB,CAACW,SAAS,CAAC;EAC9E,IAAI,CAACG,oBAAoB,EAAE;IACzB,MAAM,IAAIvC,KAAK,aAAWyB,iBAAiB,CAACW,SAAS,6CAA0C;;EAEjG,IAAMK,4BAA4B,GAAkChB,iBAAiB,CAACgB,4BAA4B,CAACX,MAAM,CAAC,UAAAY,IAAI;IAAA,OAAIA,IAAI,CAACC,UAAU,KAAKJ,oBAAoB;IAAC;EAC3K,IAAIE,4BAA4B,CAAC5C,MAAM,KAAK,CAAC,EAAE;IAC7C,MAAM,IAAIG,KAAK,kDAAgDuC,oBAAoB,+CAA4C;GAChI,MACI,IAAIE,4BAA4B,CAAC5C,MAAM,GAAG,CAAC,EAAE;IAChD,MAAM,IAAIG,KAAK,kEAAgEuC,oBAAoB,kCAA+B;GACnI,MACI;IACHJ,2BAA2B,GAAGM,4BAA4B,CAAC,CAAC,CAAC;;EAE/D,OAAON,2BAA2B,CAACT,UAAU;AAC/C,CAAC;AAGD,IAAMkB,sCAAsC,GAA8B,SAApEA,sCAAsC,CAA+BnB,iBAAiD;EAC1H,MAAM,IAAIzB,KAAK,CAAC,iBAAiB,CAAC;;;;;;;;;AASpC,CAAC;;AAGD,IAAM6C,0CAA0C,GAA8B,SAAxEA,0CAA0C,CAA+BpB,iBAAqD;EAClI,MAAM,IAAIzB,KAAK,CAAC,iBAAiB,CAAC;;;;;;;;;;;;;AAapC,CAAC;;AAGD,IAAM8C,0BAA0B,gBAAG,IAAIC,GAAG,EAAoD;AAC9FD,0BAA0B,CAACE,GAAG,CAACzB,qBAAqB,CAAC0B,iBAAiB,EAAEzB,0CAA0C,CAAC;AACnHsB,0BAA0B,CAACE,GAAG,CAACzB,qBAAqB,CAAC2B,eAAe,EAAEvB,wCAAwC,CAAC;AAC/GmB,0BAA0B,CAACE,GAAG,CAACzB,qBAAqB,CAAC4B,WAAW,EAAEnB,oCAAoC,CAAC;AACvGc,0BAA0B,CAACE,GAAG,CAACzB,qBAAqB,CAAC6B,SAAS,EAAEnB,kCAAkC,CAAC;AACnGa,0BAA0B,CAACE,GAAG,CAACzB,qBAAqB,CAAC8B,cAAc,EAAEnB,uCAAuC,CAAC;AAC7GY,0BAA0B,CAACE,GAAG,CAACzB,qBAAqB,CAAC+B,aAAa,EAAEV,sCAAsC,CAAC;AAC3GE,0BAA0B,CAACE,GAAG,CAACzB,qBAAqB,CAACgC,iBAAiB,EAAEV,0CAA0C,CAAC;AAGnH,AAAO,IAAMW,4BAA4B,GAAG,SAA/BA,4BAA4B,CAAIC,qBAA4C;EACvFlD,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,yDAAoDqE,qBAAqB,UAAO;EAChH,IAAMC,yBAAyB,GAAGZ,0BAA0B,CAACN,GAAG,CAACiB,qBAAqB,CAAC;EACvF,IAAI,CAACC,yBAAyB,EAAE;IAC9B,MAAM,IAAI1D,KAAK,iDAA+CyD,qBAAqB,0BAAuB;;EAE5G,OAAOC,yBAAyB;AAClC,CAAC;;ACjID,IAAYC,oBAOX;AAPD,WAAYA,oBAAoB;EAC9BA,uDAA+B;EAC/BA,uCAAe;EACfA,2DAAmC;EACnCA,qEAA6C;EAC7CA,qDAA6B;EAC7BA,iEAAyC;AAC3C,CAAC,EAPWA,oBAAoB,KAApBA,oBAAoB;;ACOhC,IAAMC,qCAAqC,GAA6B,SAAlEA,qCAAqC,CAA8BC,gBAA+C,EAAEC,qBAA0B;EAClJ,IAAI,OAAOA,qBAAqB,KAAK,QAAQ,EAAE;IAC7C,MAAM,IAAI9D,KAAK,gFAA8E,OAAO8D,qBAAqB,OAAI;;EAE/H,OAAO,IAAI1C,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;IACjCD,OAAO,CAACyC,qBAAqB,CAAC;GAC/B,CAAC;AACJ,CAAC;AAGD,IAAMC,6BAA6B,GAA6B,SAA1DA,6BAA6B,CAA8BF,gBAAuC,EAAEC,qBAA0B;EAClI,IAAK,OAAOA,qBAAqB,KAAK,UAAU,IAAM,OAAOA,qBAAqB,CAACE,WAAW,KAAK,UAAW,EAAE;IAC9G,MAAM,IAAIhE,KAAK,uEAAqE,OAAO8D,qBAAqB,OAAI;;EAEtH,IAAK,CAAC,CAACD,gBAAgB,CAACI,eAAe,IAAM,CAACC,KAAK,CAACC,OAAO,CAACN,gBAAgB,CAACI,eAAe,CAAE,EAAE;IAC9F,MAAM,IAAIjE,KAAK,CAAC,8DAA8D,CAAC;;EAEjF,OAAO,IAAIoB,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;;IACjC,IAAM8C,SAAS,mBAAwB,KAAK,yBAAAC,QAAQ,CAACC,SAAS,CAACC,IAAI,EAACC,IAAI,+BAACV,qBAAqB,EAAEW,SAAS,SAAKZ,gBAAgB,CAACI,eAAe,EAAC,GAAG;IAClJ5C,OAAO,CAAC+C,SAAS,CAAC;GACnB,CAAC;AACJ,CAAC;AAGD,IAAMM,uCAAuC;EAAA,mFAA6B,iBAAOb,gBAAiD,EAAEC,qBAA+B;IAAA;MAAA;QAAA;UAAA,MAC7J,OAAOA,qBAAqB,KAAK,UAAU;YAAA;YAAA;;UAAA,MACvC,IAAI9D,KAAK,kFAAgF,OAAO8D,qBAAqB,OAAI;QAAA;UAAA,MAE5H,CAAC,CAACD,gBAAgB,CAACc,YAAY,IAAM,CAACT,KAAK,CAACC,OAAO,CAACN,gBAAgB,CAACc,YAAY,CAAE;YAAA;YAAA;;UAAA,MAChF,IAAI3E,KAAK,CAAC,8DAA8D,CAAC;QAAA;UAAA;UAAA,OAEpE8D,qBAAqB,CAACc,KAAK,CAACH,SAAS,EAAEZ,gBAAgB,CAACc,YAAY,CAAC;QAAA;UAAA;QAAA;QAAA;UAAA;;;GACnF;EAAA,gBARKD,uCAAuC;IAAA;;AAAA,GAQ5C;AAGD,IAAMG,4CAA4C;EAAA,oFAA6B,kBAAOhB,gBAAsD,EAAEC,qBAA0B;IAAA;IAAA;MAAA;QAAA;UAAA,MAClK,OAAOA,qBAAqB,KAAK,QAAQ;YAAA;YAAA;;UAAA,MACrC,IAAI9D,KAAK,wFAAsF,OAAO8D,qBAAqB,OAAI;QAAA;UAAA,IAElID,gBAAgB,CAACiB,UAAU;YAAA;YAAA;;UAAA,MACxB,IAAI9E,KAAK,CAAC,+CAA+C,CAAC;QAAA;UAE5D+E,aAAa,GAAajB,qBAAqB,CAACD,gBAAgB,CAACiB,UAAU,CAAC;UAAA,IAC7EC,aAAa;YAAA;YAAA;;UAAA,MACV,IAAI/E,KAAK,4BAA0B6D,gBAAgB,CAACiB,UAAU,oDAAiD;QAAA;UAAA,MAEnH,OAAOC,aAAa,KAAK,UAAU;YAAA;YAAA;;UAAA,MAC/B,IAAI/E,KAAK,qCAAmC6D,gBAAgB,CAACiB,UAAU,6CAAwC,OAAOC,aAAa,OAAI;QAAA;UAAA,MAE1I,CAAC,CAAClB,gBAAgB,CAACmB,UAAU,IAAM,CAACd,KAAK,CAACC,OAAO,CAACN,gBAAgB,CAACmB,UAAU,CAAE;YAAA;YAAA;;UAAA,MAC5E,IAAIhF,KAAK,CAAC,4DAA4D,CAAC;QAAA;UAAA;UAAA,OAElE+E,aAAa,CAACH,KAAK,CAACd,qBAAqB,EAAED,gBAAgB,CAACmB,UAAU,CAAC;QAAA;UAAA;QAAA;QAAA;UAAA;;;GACrF;EAAA,gBAlBKH,4CAA4C;IAAA;;AAAA,GAkBjD;AAGD,IAAMI,oCAAoC,GAA6B,SAAjEA,oCAAoC,CAA8BpB,gBAA8C,EAAEC,qBAA0B;EAChJ,MAAM,IAAI9D,KAAK,CAAC,iBAAiB,CAAC;;;;;AAKpC,CAAC;;AAGD,IAAMkF,0CAA0C,GAA6B,SAAvEA,0CAA0C,CAA8BrB,gBAAoD,EAAEC,qBAA0B;EAC5J,MAAM,IAAI9D,KAAK,CAAC,iBAAiB,CAAC;;;;AAIpC,CAAC;;AAGD,IAAMmF,yBAAyB,gBAAG,IAAIpC,GAAG,EAAkD;AAC3FoC,yBAAyB,CAACnC,GAAG,CAACW,oBAAoB,CAACyB,aAAa,EAAExB,qCAAqC,CAAC;AACxGuB,yBAAyB,CAACnC,GAAG,CAACW,oBAAoB,CAAC0B,KAAK,EAAEtB,6BAA6B,CAAC;AACxFoB,yBAAyB,CAACnC,GAAG,CAACW,oBAAoB,CAAC2B,eAAe,EAAEZ,uCAAuC,CAAC;AAC5GS,yBAAyB,CAACnC,GAAG,CAACW,oBAAoB,CAAC4B,oBAAoB,EAAEV,4CAA4C,CAAC;AACtHM,yBAAyB,CAACnC,GAAG,CAACW,oBAAoB,CAAC6B,YAAY,EAAEP,oCAAoC,CAAC;AACtGE,yBAAyB,CAACnC,GAAG,CAACW,oBAAoB,CAAC8B,kBAAkB,EAAEP,0CAA0C,CAAC;AAElH,AAAO,IAAMQ,2BAA2B,GAAG,SAA9BA,2BAA2B,CAAIC,oBAA0C;EACpFpF,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,wDAAmDuG,oBAAoB,UAAO;EAC9G,IAAMC,wBAAwB,GAAGT,yBAAyB,CAAC3C,GAAG,CAACmD,oBAAoB,CAAC;EACpF,IAAI,CAACC,wBAAwB,EAAE;IAC7B,MAAM,IAAI5F,KAAK,+CAA6C2F,oBAAoB,0BAAuB;;EAEzG,OAAOC,wBAAwB;AACjC,CAAC;;AC/FD,IAAYC,qBAGX;AAHD,WAAYA,qBAAqB;EAC/BA,8CAAqB;EACrBA,8CAAqB;AACvB,CAAC,EAHWA,qBAAqB,KAArBA,qBAAqB;;ACOjC,IAAMC,iCAAiC;EAAA,mFAA8B,iBAAOC,iBAA4C,EAAE3B,SAAc;IAAA;MAAA;QAAA;UAAA,iCAE/H,IAAIhD,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;YACjCD,OAAO,EAAE;WACV,CAAC;QAAA;QAAA;UAAA;;;GACH;EAAA,gBALKyE,iCAAiC;IAAA;;AAAA,GAKtC;AAGD,IAAME,iCAAiC;EAAA,oFAA8B,kBAAOD,iBAA4C,EAAE3B,SAAc;IAAA;IAAA;MAAA;QAAA;UAAA,IACjI2B,iBAAiB,CAACjB,UAAU;YAAA;YAAA;;UAAA,MACzB,IAAI9E,KAAK,CAAC,gDAAgD,CAAC;QAAA;UAE7DiG,wBAAwB,GAAa7B,SAAS,CAAC2B,iBAAiB,CAACjB,UAAU,CAAC;UAAA,IAC7EmB,wBAAwB;YAAA;YAAA;;UAAA,MACrB,IAAIjG,KAAK,8BAA4B+F,iBAAiB,CAACjB,UAAU,wCAAqC;QAAA;UAAA,MAE1G,OAAOmB,wBAAwB,KAAK,UAAU;YAAA;YAAA;;UAAA,MAC1C,IAAIjG,KAAK,uCAAqC+F,iBAAiB,CAACjB,UAAU,6CAAwC,OAAOmB,wBAAwB,OAAI;QAAA;UAAA,MAExJ,CAAC,CAACF,iBAAiB,CAACf,UAAU,IAAM,CAACd,KAAK,CAACC,OAAO,CAAC4B,iBAAiB,CAACf,UAAU,CAAE;YAAA;YAAA;;UAAA,MAC9E,IAAIhF,KAAK,CAAC,6DAA6D,CAAC;QAAA;UAAA;UAAA,OAE1EiG,wBAAwB,CAACrB,KAAK,CAACR,SAAS,EAAE2B,iBAAiB,CAACf,UAAU,CAAC;QAAA;QAAA;UAAA;;;GAC9E;EAAA,gBAfKgB,iCAAiC;IAAA;;AAAA,GAetC;AAGD,IAAME,0BAA0B,gBAAG,IAAInD,GAAG,EAAoD;AAC9FmD,0BAA0B,CAAClD,GAAG,CAAC6C,qBAAqB,CAACM,QAAQ,EAAEL,iCAAiC,CAAC;AACjGI,0BAA0B,CAAClD,GAAG,CAAC6C,qBAAqB,CAACO,QAAQ,EAAEJ,iCAAiC,CAAC;AAEjG,AAAO,IAAMK,4BAA4B,GAAG,SAA/BA,4BAA4B,CAAIC,qBAA4C;EACvF/F,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,yDAAoDkH,qBAAqB,UAAO;EAChH,IAAMC,yBAAyB,GAAGL,0BAA0B,CAAC1D,GAAG,CAAC8D,qBAAqB,CAAC;EACvF,IAAI,CAACC,yBAAyB,EAAE;IAC9B,MAAM,IAAIvG,KAAK,gDAA8CsG,qBAAqB,0BAAuB;;EAE3G,OAAOC,yBAAyB;AAClC,CAAC;;AC1CD,IAAMC,MAAM,GAAG,SAATA,MAAM,CAAOC,IAAa;EAAA,OAAKA,IAAI;AAAA;AAEzC,AAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAa,CAAIhF,UAAsB,EAAEiF,uBAA4B;;EAEhF,IAAIC,oBAAoB,GAAa,EAAE;EACvC,IAAID,uBAAuB,CAACE,QAAQ,KAAKnF,UAAU,CAAC+E,IAAI,EAAE;IACxDG,oBAAoB,CAACE,IAAI,CAACN,MAAM,CAAa,MAAM,CAAC,CAAC;;EAEvD,IAAIG,uBAAuB,CAACI,eAAe,KAAKrF,UAAU,CAACsF,OAAO,EAAE;IAClEJ,oBAAoB,CAACE,IAAI,CAACN,MAAM,CAAa,SAAS,CAAC,CAAC;;EAE1D,IAAIG,uBAAuB,CAACM,WAAW,KAAKvF,UAAU,CAACuF,WAAW,EAAE;IAClEL,oBAAoB,CAACE,IAAI,CAACN,MAAM,CAAa,aAAa,CAAC,CAAC;;EAG9D,IAAII,oBAAoB,CAAC/G,MAAM,GAAG,CAAC,EAAE;IACnCU,OAAO,CAAC2G,KAAK,gIAA8HN,oBAAoB,CAACO,IAAI,CAAC,IAAI,CAAC,OAAI;IAC9K5G,OAAO,CAAC2G,KAAK,CAAC,2BAA2B,CAAC;IAC1C3G,OAAO,CAAC2G,KAAK,CAACxF,UAAU,CAAC;IACzBnB,OAAO,CAAC2G,KAAK,CAAC,mCAAmC,CAAC;IAClD3G,OAAO,CAAC2G,KAAK,CAACP,uBAAuB,CAAC;IACtC,MAAM,IAAI3G,KAAK,CAAC,eAAe,CAAC;;AAEpC,CAAC;;ICLYoH,aAAa,GAA0B;EAClDC,OAAO,EAAE;IACP,IAAMC,iBAAiB,GAAsB;MAC3CC,aAAa,EAAEnI,iBAAiB;MAChCoI,gBAAgB,EAAEnI;KACnB;IACD,OAAO,IAAI+B,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;MACjCD,OAAO,CAACiG,iBAAiB,CAAC;KAC3B,CAAC;GACH;EAEDG,YAAY;IAAA,4FAAE,iBAAenH,YAAmC;MAAA;MAAA;QAAA;UAAA;YAAA,KAG1Db,MAAM,CAACiI,IAAI;cAAA;cAAA;;YACbtD,SAAS,GAAG3E,MAAM,CAACiI,IAAI;YACvBnH,OAAO,CAACC,GAAG,wEAAsEpB,iBAAiB,UAAKC,oBAAoB,mGAAgG,mBAAmB,CAAC;YAAC;YAAA;UAAA;YAAA;YAAA,OAIjMgB,kBAAkB,CAACC,YAAY,CAAC;UAAA;YAAzEU,eAAe;YAAA,IAEhBA,eAAe,CAACS,iBAAiB;cAAA;cAAA;;YAAA,MAC9B,IAAIzB,KAAK,CAAC,qCAAqC,CAAC;UAAA;YAElD0D,yBAAyB,GAAGF,4BAA4B,CAACxC,eAAe,CAACS,iBAAiB,CAACkG,IAAI,CAAC;YAChGC,oBAAoB,GAAelE,yBAAyB,CAAC1C,eAAe,CAACS,iBAAiB,CAAC;YAErGlB,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,wDAAmDwI,oBAAoB,CAACnB,IAAI,UAAO;YAC7GoB,YAAY,GAAyB7G,eAAe,CAACC,iBAAkB,CAACa,MAAM,CAAC,UAACgG,EAAsB;cAAA,OAAOA,EAAE,CAACpG,UAAU,CAAC+E,IAAI,KAAKmB,oBAAoB,CAACnB,IAAI,KAAO,CAACmB,oBAAoB,CAACZ,OAAO,IAAMc,EAAE,CAACpG,UAAU,CAACsF,OAAO,KAAKY,oBAAoB,CAACZ,OAAQ,CAAC,KAAM,CAACY,oBAAoB,CAACX,WAAW,IAAMa,EAAE,CAACpG,UAAU,CAACuF,WAAW,KAAKW,oBAAoB,CAACX,WAAY,CAAC;aAAC,CAAC;YAAA,MAChXY,YAAY,CAAChI,MAAM,KAAK,CAAC;cAAA;cAAA;;YAAA,MACrB,IAAIG,KAAK,8BAA4B4H,oBAAoB,CAACnB,IAAI,mDAAgD;UAAA;YAAA,MAE7GoB,YAAY,CAAChI,MAAM,GAAG,CAAC;cAAA;cAAA;;YAAA,MACxB,IAAIG,KAAK,yCAAuC4H,oBAAoB,CAACnB,IAAI,0CAAuC;UAAA;YAGtHsB,WAAW,GAAGF,YAAY,CAAC,CAAC,CAAC;;YAE7BtH,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,kDAA6C2I,WAAW,CAACC,sBAAsB,CAACC,SAAS,UAAO;YAAC;YAAA,OACnG,iCAAgCF,WAAW,CAACC,sBAAsB,CAACC,SAAS,CAAC;UAAA;YAArGC,eAAe;YAAA,IAChBA,eAAe;cAAA;cAAA;;YAAA,MACZ,IAAIlI,KAAK,uDAAqD+H,WAAW,CAACC,sBAAsB,CAACC,SAAS,OAAI;UAAA;;YAGhHE,qBAAqB,GAAGJ,WAAW,CAACC,sBAAsB,CAACI,YAAY,IAAI,SAAS;YAC1F7H,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,wDAAmD+I,qBAAqB,UAAO;YACzGrE,qBAAqB,GAAQoE,eAAe,CAACC,qBAAqB,CAAC;YAAA,IACpErE,qBAAqB;cAAA;cAAA;;YAAA,MAClB,IAAI9D,KAAK,+CAA6CmI,qBAAqB,kCAA6BJ,WAAW,CAACC,sBAAsB,CAACC,SAAS,OAAI;UAAA;YAAA,IAG3JF,WAAW,CAACC,sBAAsB,CAACnE,gBAAgB;cAAA;cAAA;;YAAA,MAChD,IAAI7D,KAAK,CAAC,oCAAoC,CAAC;UAAA;YAEjD4F,wBAAwB,GAAGF,2BAA2B,CAACqC,WAAW,CAACC,sBAAsB,CAACnE,gBAAgB,CAAC8D,IAAI,CAAC;YACtHpH,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,6BAAwB2I,WAAW,CAACrG,UAAU,CAAC+E,IAAI,UAAKsB,WAAW,CAACrG,UAAU,CAACsF,OAAO,SAAM;YAAC;YAAA,OAC3GpB,wBAAwB,CAACmC,WAAW,CAACC,sBAAsB,CAACnE,gBAAgB,EAAEC,qBAAqB,CAAC;UAAA;YAAtHM,SAAS;YAAA,IAEJ2D,WAAW,CAACC,sBAAsB,CAACjC,iBAAiB;cAAA;cAAA;;YAAA,MACjD,IAAI/F,KAAK,CAAC,qCAAqC,CAAC;UAAA;YAElDuG,yBAAyB,GAAGF,4BAA4B,CAAC0B,WAAW,CAACC,sBAAsB,CAACjC,iBAAiB,CAAC4B,IAAI,CAAC;YACzHpH,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,kCAA6B2I,WAAW,CAACrG,UAAU,CAAC+E,IAAI,UAAKsB,WAAW,CAACrG,UAAU,CAACsF,OAAO,SAAM;YAAC;YAAA,OAC5HT,yBAAyB,CAACwB,WAAW,CAACC,sBAAsB,CAACjC,iBAAiB,EAAE3B,SAAS,CAAC;UAAA;YAAA,KAE5FpD,eAAe,CAACS,iBAAiB,CAAC4G,gBAAgB;cAAA;cAAA;;YACpD9H,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,yCAAoC2I,WAAW,CAACrG,UAAU,CAAC+E,IAAI,UAAKsB,WAAW,CAACrG,UAAU,CAACsF,OAAO,SAAM;YAAC;YAAA,OACnG5C,SAAS,CAACiD,OAAO,EAAE;UAAA;YAAnDV,uBAAuB;YAC7BD,aAAa,CAACqB,WAAW,CAACrG,UAAU,EAAEiF,uBAAuB,CAAC;UAAC;YAEjEpG,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,4EAAuE2I,WAAW,CAACrG,UAAU,CAAC+E,IAAI,UAAKsB,WAAW,CAACrG,UAAU,CAACsF,OAAO,CAAG;;YAExKzG,OAAO,CAACC,GAAG,CAAIpB,iBAAiB,iBAAc;UAAC;YAAA,iCAG5C,IAAIgC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;cACjC,IAAMgH,iBAAiB,GAAsB;gBAC3CC,kBAAkB,EAAER,WAAW;gBAC/BL,IAAI,EAAEtD;eACP;cACD/C,OAAO,CAACiH,iBAAiB,CAAC;aAC3B,CAAC;UAAA;UAAA;YAAA;;;KACH;IAAA;MAAA;;IAAA;;CACF;;;;"}